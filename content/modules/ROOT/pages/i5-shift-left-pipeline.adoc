= Lab: Shift Left – CI/CD Scanning & Signing Pipeline
:role: Intermediate Supply Chain
:skills: Tekton, Image Scanning, Signing, Admission Gating
:labid: LAB-I5
:toc:
:sectnums:
:icons: font

== Skill
Integrate security scanning and policy checks into pipelines.

== Scenario
You will build a minimal Tekton pipeline: build image → vulnerability scan → sign if clean → deploy gated by signature & digest. Scanning tool abstracted (use placeholder task if actual scanner unavailable). Demonstrates supply chain policy flow.

== Objectives
* Create Tekton Tasks: build, scan, sign
* Use Pipeline + PipelineRun with workspaces & results
* Add policy gate (simple result check) before signing
* Reference signed image by digest in a Deployment

== Prerequisites
* OpenShift Pipelines (Tekton) Operator installed
* Cosign installed locally (optional) or simulate signing

== Namespace & Service Account
Tekton CRDs require YAML; only typos fixed and kept minimal.
[source,sh]
----
oc new-project i5-pipeline
och create sa pipeline -n i5-pipeline
oc adm policy add-scc-to-user anyuid -z pipeline -n i5-pipeline  # only if build strategy requires
----

== Build Task (S2I or Buildah Simplified)
[source,sh]
----
oc apply -n i5-pipeline -f - <<'EOF'
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: build-image
spec:
  results:
  - name: image-digest
  params:
  - name: IMAGE
  steps:
  - name: build
    image: registry.access.redhat.com/ubi9/buildah
    script: |
      #!/usr/bin/env bash
      set -e
      touch index.html; echo Hello > index.html
      buildah bud -t $(params.IMAGE) .
      buildah push $(params.IMAGE)
      DIGEST=$(skopeo inspect docker://$(params.IMAGE) | jq -r .Digest)
      echo -n "$DIGEST" > $(results.image-digest.path)
EOF
----

== Scan Task (Simulated)
[source,sh]
----
oc apply -n i5-pipeline -f - <<'EOF'
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: scan-image
spec:
  params:
  - name: IMAGE
  results:
  - name: scan-status
  steps:
  - name: scan
    image: registry.access.redhat.com/ubi9/ubi
    script: |
      #!/usr/bin/env bash
      echo "Simulating vulnerability scan"
      # set FAIL=1 to simulate failure
      if [ "$FAIL" = "1" ]; then echo -n FAIL > $(results.scan-status.path); exit 1; fi
      echo -n PASS > $(results.scan-status.path)
EOF
----

== Sign Task (Cosign Simulated)
[source,sh]
----
oc apply -n i5-pipeline -f - <<'EOF'
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: sign-image
spec:
  params:
  - name: IMAGE
  - name: DIGEST
  steps:
  - name: sign
    image: registry.access.redhat.com/ubi9/ubi
    script: |
      #!/usr/bin/env bash
      echo "Simulating cosign sign $(params.IMAGE)@$(params.DIGEST)"
      echo "signature-ok" > /tekton/home/signature.txt
EOF
----

== Pipeline Definition
[source,sh]
----
oc apply -n i5-pipeline -f - <<'EOF'
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: secure-build
spec:
  params:
  - name: IMAGE
  tasks:
  - name: build
    taskRef:
      name: build-image
    params:
    - name: IMAGE
      value: $(params.IMAGE)
  - name: scan
    runAfter: [build]
    taskRef:
      name: scan-image
    params:
    - name: IMAGE
      value: $(params.IMAGE)
  - name: sign
    runAfter: [scan]
    when:
    - input: "$(tasks.scan.results.scan-status)"
      operator: In
      values: ["PASS"]
    taskRef:
      name: sign-image
    params:
    - name: IMAGE
      value: $(params.IMAGE)
    - name: DIGEST
      value: $(tasks.build.results.image-digest)
EOF
----

== Run Pipeline
[source,sh]
----
oc apply -n i5-pipeline -f - <<'EOF'
apiVersion: tekton.dev/v1
kind: PipelineRun
metadata:
  name: secure-build-run
spec:
  serviceAccountName: pipeline
  pipelineRef:
    name: secure-build
  params:
  - name: IMAGE
    value: image-registry.openshift-image-registry.svc:5000/i5-pipeline/demo:latest
EOF
----
Monitor:
[source,sh]
----
oc get pipelineruns -n i5-pipeline
och describe pipelinerun secure-build-run -n i5-pipeline | grep -i status
----
Get digest:
[source,sh]
----
oc get pipelinerun secure-build-run -n i5-pipeline -o jsonpath='{.status.pipelineResults}'
----

== Deployment Using Digest (Gate Simulation)
Replace <DIGEST> with extracted digest:
[source,sh]
----
oc apply -n i5-pipeline -f - <<'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  replicas: 1
  selector:
    matchLabels: {app: demo}
  template:
    metadata:
      labels: {app: demo}
    spec:
      containers:
      - name: web
        image: image-registry.openshift-image-registry.svc:5000/i5-pipeline/demo@sha256:<DIGEST>
EOF
----

== (Optional) Admission Tie-In
Add Gatekeeper policy to require annotation `signed=ok` or actual cosign verification (see I10 lab) before allowing tag-based images.

== Failure Simulation
Re-run with FAIL=1 env (edit scan task to export) and confirm sign task skipped.

== Cleanup
[source,sh]
----
oc delete project i5-pipeline --wait=false
----

== Key Points
* Pipeline enforces scan-before-sign
* Conditional task (when clause) implements gate
* Digest pin ensures immutability; admission can extend trust policies
* Extensible to SBOM generation & policy-as-code checks
