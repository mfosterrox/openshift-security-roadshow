= Lab: Default Secure Behavior & Why OpenShift Differs from Vanilla Kubernetes
:labid: LAB-101-01
:cis-summary: "Run containers as non-root and avoid privileged/low ports to enforce least privilege."
:mitre-summary: "Prevents container-to-host escalation by enforcing non-root execution and avoiding privileged port binds."
:audit-evidence: "Root-based httpd on port 80 fails; UBI httpd on 8080 runs with random non-root UID and accessible route."
:cis-mitre-codes: '{"cisMapping":{"primary":["5.2.5","5.2.6"],"related":["5.2.1","5.2.10"]},"mitre":{"techniques":["T1611"],"tactics":["TA0004"],"mitigations":["M1026","M1048"]}}'
:toc:
:sectnums:
:icons: font

== Skill
Learn why OpenShift enforces strict security rules (like running containers as non-root users and avoiding privileged ports like 80) because it assumes workloads weren't built with security best practices in mind. You'll discover how choosing or building images designed for these rules (e.g., using a non-root user and high ports like 8080) makes deployment smoother and safer, eliminating the need for risky security exceptions while demonstrating the benefits of least privilege.

== Objective

* Deploy a public Docker Hub `httpd` image (implicit root + port 80) and observe failure under default guardrails
* Read logs to identify privileged port + ownership assumptions
* Redeploy using a trusted Red Hat UBI `httpd` image (non-root friendly, high port) and observe success without escalation
* Expose the working service via a Route
* Compare external vs curated image from security, reliability, and compliance perspectives

== Why it Matters
Imagine an office tower where the building management assumes every new tenant forgot to set up internal badge rules. Instead of trusting everyone, doors default to locked, access is scoped, and reception screens visitors. That's OpenShift: it does NOT assume developers applied security best practices, it assumes the opposite and installs guardrails to compensate. A container that "just worked" on a laptop (root + port 80) collides with these controls and fails fast. That failure isn't punishment; it's feedback. It prevents: unnecessary root power, accidental data exposure, shortened attacker dwell time, and audit headaches.

Business value: guardrails turn silent risk into visible learning. Non-root + high-port norms reduce exploit blast radius, simplify compliance evidence ("all workloads run non-root"), and strengthen customer trust. Most security incidents aren't cinematic hacks, they're misconfigurations and permissive defaults. OpenShift converts risky assumptions into an engineered safety net.

== What it Solves
This lab exposes a chain of quiet assumptions: "root is fine," "port 80 is normal," "logs can write to root-owned directories," "public images are good enough." On a laptop these blend into the background because the environment is single-tenant and permissive. In a shared platform every one of those assumptions widens attack surface or slows audits. Attackers don't need brilliance when defaults gift them privileges; they only need one container running as root or one mis-owned directory to pivot. OpenShift breaks this chain by injecting a random non-root UID and refusing privileged binds, forcing images to be explicit about what they truly need. The failure of the external `httpd` image is a design review in disguise. The success of the UBI variant demonstrates that secure defaults (non-root user, high port readiness, sane permissions) remove friction rather than add it.

== Understanding the Attack Surface
[cols="1,2,2",options="header"]
|===
|Area | Risk If Misconfigured | Analogy
|Root User in Container | Rapid escalation path to node | Guest given master key
|Privileged Port (80) | Forces elevation / capability grants | Only main lobby door allowed
|Fixed UID / Ownership | Leads to "just grant anyuid" drift | Furniture bolted for one person
|Unvetted External Image | Unknown vulns / supply chain gaps | Unsealed package from street vendor
|Broad Exceptions (anyuid) | Normalizes long-term risk | Leaving fire door propped open
|===

== How to Try It (~15 minutes)

Narrative: One deployment. First it fails (external image expecting root + port 80). You inspect why using the CLI, then replace the image with a trusted UBI variant (non‑root, high port), expose a Route, and verify end-to-end—all from the command line.

=== Use case 1: Create project and deploy external image (~2 min)

Create a dedicated project and deploy the public Docker Hub `httpd` image. OpenShift will accept the deployment but the container will fail at runtime due to default security guardrails.

[source,sh]
----
oc new-project 101-01-httpd-demo
oc create deployment web --image=httpd
----

Wait a few seconds for the pod to start (and then fail). Check pod status and restart count:

[source,sh]
----
oc get pods -l app=web
oc get pods -l app=web -o wide
----

You should see the pod in `CrashLoopBackOff` or `Error` with a non-zero restart count.

=== Use case 2: Observe failure — logs and events (~3 min)

Inspect why the container failed using logs and cluster events. These commands are your first line of evidence for "why didn't this work?"

[source,sh]
----
oc logs -l app=web --tail=50 --all-containers=true
----

Expected failure snippet:
[source,text]
----
AH00558: httpd: Could not reliably determine the server's fully qualified domain name...
(13)Permission denied: AH00072: make_sock: could not bind to address [::]:80
(13)Permission denied: AH00072: make_sock: could not bind to address 0.0.0.0:80
no listening sockets available, shutting down
AH00015: Unable to open logs
----

Check recent events for the deployment and pod (SCC, image pull, or runtime messages):

[source,sh]
----
oc get events --sort-by='.lastTimestamp' | tail -20
oc describe pod -l app=web | tail -30
----

Reason: Port 80 requires elevated privileges; log directories are root-owned; OpenShift injects a random non-root UID, so the process cannot bind to 80 or write to default log paths.

=== Use case 3: Confirm runtime user and port assumption (~2 min)

Inspect the pod spec to see that OpenShift has applied a non-root security context (runAsUser, etc.). The image expects root and port 80, but the platform overrides the user.

[source,sh]
----
oc get pod -l app=web -o jsonpath='{.items[0].spec.securityContext}' ; echo
oc get pod -l app=web -o jsonpath='Container port: {.items[0].spec.containers[0].ports[0].containerPort}{"\n"}' ; echo
----

You should see a numeric `runAsUser` (or similar) in the security context and port 80 in the container spec. The takeaway: the platform assigns a random non-root UID while the image was built assuming root and binding to port 80, so the process fails.

=== Use case 4: Replace image with trusted UBI httpd (~2 min)

Replace the image in-place with a Red Hat UBI image that is designed for non-root and listens on 8080. No privilege escalation or SCC changes required.

[cols="1,2",options="header"]
|===
|Best practice | Why it matters
|Non-root user | Works with OpenShift's random UID; least privilege
|High port (8080) | Avoids privileged port 80 and extra capabilities
|Curated & supported | Regular patches, lower risk, clear provenance
|===

[source,sh]
----
oc set image deployment/web *=registry.access.redhat.com/ubi9/httpd-24
oc rollout status deployment/web --timeout=120s
----

Verify the new pod is running and check logs:

[source,sh]
----
oc get pods -l app=web
oc logs -l app=web --tail=15
----

=== Use case 5: Verify non-root UID and expose the service (~2 min)

Confirm the running container has a random non-root UID, then expose the deployment via an OpenShift Route so you can reach it from outside the cluster.

[source,sh]
----
oc exec deploy/web -- id
oc exec deploy/web -- id -u
----

Expect a numeric UID such as `1000690000` (not `0`). Then create a Route and note the hostname:

[source,sh]
----
oc expose deployment web --port=8080
oc get route web -o jsonpath='{.spec.host}{"\n"}'
----

=== Use case 6: Test the route from the command line (~2 min)

Use `curl` (or `oc run` plus `curl` from inside the cluster) to hit the Route and confirm the UBI httpd response.

[source,sh]
----
ROUTE=$(oc get route web -o jsonpath='{.spec.host}')
curl -s -o /dev/null -w "%{http_code}" "http://$ROUTE/" && echo " OK"
curl -s "http://$ROUTE/" | head -5
----

If you're running from a host that cannot resolve the cluster's internal DNS, use the cluster's default ingress or port-forward instead:

[source,sh]
----
oc get route web -o jsonpath='{.spec.host}'
# Then open that URL in a browser, or from a machine that can resolve it:
# curl -s http://<route-host>/
----

=== Use case 7: Compare before/after (summary table)

[cols="1,2,1,1,1,2",options="header"]
|===
|Scenario | Image | Port | UID | Result | Reason
|Laptop local (implicit root) | docker.io/httpd:latest | 80 | 0 | Works | Root + privileged bind allowed
|OpenShift (before swap) | docker.io/httpd:latest | 80 | random | Fails | Guardrails block privileged assumptions
|OpenShift (after swap) | registry.access.redhat.com/ubi9/httpd-24 | 8080 | random | Succeeds | Built for non-root + high port
|===

=== Cleanup (~1 min)

[source,sh]
----
oc delete project 101-01-httpd-demo --wait=false
----

== Solutions / Controls
[cols="1,2",options="header"]
|===
|Control | Purpose (Analogy)
|SCC (restricted) | Enforces least privilege (locked interior doors)
|UBI Base Images | Curated foundations (certified building materials)
|High Port Usage | Removes need for elevation (use side entrance instead of main vault door)
|Image Scanning / Signing | Provenance + integrity (seal + manifest)
|RHACS Policies | Continuous watch (security concierge)
|Digest Pinning | Immutable versioning (invoice number vs vague description)
|===

== Summary Table
[cols="1,2,2",options="header"]
|===
|What to Secure | Problem If Ignored | How to Secure
|Container User | Root misuse risk | Accept random non-root; avoid anyuid
|Listening Port | Privileged bind needs root | Use 8080+
|File Ownership | Crash / log failures | Pre-create + group-write dirs
|Image Provenance | Hidden vulns/backdoors | Curated UBI + scanning/signing
|Version Drift | Inconsistent rollbacks | Pin image digests
|Privilege Exceptions | Normalized risk | Track & review exceptions
|===

== FAQs
Why did it work locally?:: Your local environment let the container run as root and bind port 80, no guardrails.
Does OpenShift "distrust" my image?:: It assumes nothing was hardened yet and applies defaults that are safe even for naive builds.
Isn't granting anyuid easier?:: Short term yes; long term it expands audit scope and risk. Fix the image instead.
Why avoid privileged ports?:: They require elevation; high ports remove the need entirely and simplify compliance evidence.
How do curated images help?:: They bake in sane permissions and are maintained, reducing unknown vulnerabilities and operational toil.
What if I must run root?:: Create a documented exception with justification, scope, and expiration. Treat it like a temporary safety override.

== Closing Story
OpenShift's model is "secure-by-default through skepticism." It behaves like a facilities team that locks doors and limits master keys because experience shows not every tenant configures safety correctly the first time. By embracing those guardrails, rather than bypassing them, you convert invisible risk into durable engineering hygiene.

== Next Step Ideas

* Add pipeline policy: reject Dockerfiles ending with USER 0
* Integrate cosign + RHACS to enforce signature presence
* Track KPIs: % non-root, % digest-pinned, mean time to remediate root exceptions
