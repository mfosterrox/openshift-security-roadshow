= Lab: Write Your Own Keycard – Custom RBAC in Action
:role: Intermediate Platform Security
:skills: Custom RBAC, Least Privilege Design, Scoped Identities, Service Account Hardening
:mitre: T1078 (Valid Accounts), TA0004 (Privilege Escalation), T1552 (Credential Access)
:compliance: NIST 800-53 AC-6, ISO 27001 A.9, SOC 2 CC6, PCI DSS 7
:labid: LAB-I2

== Skill
By the end you’ll be able to design and apply a narrowly scoped Role that grants only the handful of permissions an application maintainer truly needs, verify what works, prove what is denied, and explain how that shrinks incident blast radius.

== Objective
* Create a minimal, purpose‑built Role (get,list,update,patch on ConfigMaps & Secrets)
* Bind it to a user (and a service account variation)
* Demonstrate allowed vs denied verbs
* Explain least privilege in plain business terms
* Show how to audit and iterate safely

== Why it Matters
Imagine an office where every employee’s badge opens every room—including finance, HR, and the server closet. Nobody intends abuse, but one lost badge means a long night of worrying what was accessed. Built‑in broad roles (`edit`, `admin`) are those master badges. Custom RBAC is like cutting a key that only opens the supply cabinet your role requires. When (not if) an account is phished or a token is leaked, tightly scoped permissions turn a potential headline into a routine ticket. Auditors also smile when intent is obvious: “This identity may only adjust configuration.”

== What it Solves
Most real security incidents aren’t cinematic hacks—they’re ordinary credentials used in extraordinary places. Over-broad roles quietly enable:
* Unapproved pod deployments (persistence footholds)
* Reading secrets far outside an app’s scope (data leakage)
* Creating new RoleBindings to escalate (privilege stacking)
* Difficult audit narratives (“Why did this CI user delete a Secret?”)

Crafting a custom Role removes silent “just in case” powers. It converts vague responsibility (“Dev team rights”) into precise intent (“May adjust non-sensitive app configuration values and rotate one secret”). That precision speeds investigations and compliance reviews.

== Understanding the Attack Surface
[options="header"]
|===
| Area | Risk with Broad Role | Reduced Risk with Custom Role
| Workload Mutation | Can create/replace pods for persistence | Cannot create pods -> persistence blocked
| Secret Exposure | Lists all secrets in namespace | Only reads designated ones
| Privilege Escalation | Can bind new roles / clusterroles | RBAC mutation verbs absent
| Lateral Movement | Wildcard verbs reveal resources to pivot | Minimal verbs limit enumeration
| Audit Clarity | Hard to explain necessity of powers | Role name + verbs tell the story
|===

== How to Secure (Lifecycle View)
* Build: Document the exact API objects the app truly needs to touch (often ConfigMaps + one Secret). Avoid “future proofing.”
* Registry: CI service accounts should only push images—no runtime object changes.
* Deploy: Replace use of `edit`/`admin` ClusterRoles with narrowly scoped namespace Roles.
* Runtime: Periodically script `oc auth can-i --as <identity>` over a small verb/resource matrix; alert on unexpected “yes.”

== How to Try It
. Create a lab namespace:
+
[source,sh]
----
oc new-project i2-rbac-lab
----
. Create a minimal Role (include patch so modern tooling works):
+
[source,sh]
----
oc create role config-secret-updater \
  --verb=get --verb=list --verb=update --verb=patch \
  --resource=configmaps,secrets
----
. Bind the Role to a (demo) user:
+
[source,sh]
----
oc create rolebinding updater-binding \
  --role=config-secret-updater --user=devuser
----
. Seed sample objects:
+
[source,sh]
----
oc create configmap app-config --from-literal=flag=on
oc create secret generic db-creds --from-literal=password=Initial123!
----
. Show allowed operations:
+
[source,sh]
----
oc auth can-i list configmaps --as devuser
oc auth can-i update secret/db-creds --as devuser
oc patch configmap app-config -p '{"data":{"flag":"off"}}' --type=merge --as devuser
oc patch secret db-creds -p '{"stringData":{"password":"Rotated456!"}}' --type=merge --as devuser
----
. Show explicit denials (proof of least privilege):
+
[source,sh]
----
oc auth can-i create pods --as devuser
oc run test --image=registry.access.redhat.com/ubi9/ubi --as devuser || echo DENIED
oc auth can-i create rolebinding --as devuser
oc create rolebinding bogus --clusterrole=view --user=devuser --as devuser || echo DENIED
oc auth can-i delete secret/db-creds --as devuser
oc delete secret db-creds --as devuser || echo DENIED
----
. Service Account variant (typical for automation):
+
[source,sh]
----
oc create sa app-sa
oc create rolebinding sa-updater \
  --role=config-secret-updater \
  --serviceaccount=i2-rbac-lab:app-sa
oc auth can-i patch configmap/app-config \
  --as system:serviceaccount:i2-rbac-lab:app-sa
----
. (Optional) Disable default token automount to shrink passive risk:
+
[source,sh]
----
oc patch sa app-sa -p '{"automountServiceAccountToken":false}'
----
. Cleanup when done:
+
[source,sh]
----
oc delete project i2-rbac-lab --wait=false
----

== Visuals (Optional)
[mermaid]
----
flowchart LR
  DevUser[devuser identity] -->|RoleBinding| Role[(Role: config-secret-updater)]
  Role --> CM[(ConfigMaps)]
  Role --> Secret[(Secrets)]
  DevUser -. denied .-> Pods
  DevUser -. denied .-> RBAC[RoleBindings]
----

== Solutions/Controls
* Custom Namespaced Roles: Encode only required verbs/resources.
* Service Accounts with Reduced Scope: Separate automation from human operators.
* Token Automount Controls: Prevent idle pods from holding live credentials.
* RHACS Policy: Flag wildcard verbs or `*` resources in new Roles.
* Periodic “Can-I” Matrix: Scripted regression test for privilege creep.

== Summary Table
[options="header"]
|===
| What to Secure | How to Secure It | Outcome
| Config change surface | Minimal Role (get,list,update,patch) | Reduced accidental damage
| Secret rotation | Scoped verbs on specific secrets | Limited credential exposure
| Pod creation path | Omit create/delete pods | Blocks persistence attempts
| RBAC mutation | Exclude role/rolebinding verbs | Stops privilege escalation
| Token exposure | Disable automount where unused | Smaller theft window
|===

== FAQs
Q: Why include the `patch` verb?:: Many controllers and CLI operations patch instead of full `update`; omitting it causes confusing denials.

Q: Should I ever allow `delete` here?:: Only if the explicit job includes lifecycle cleanup. Add it intentionally—never “just in case.”

Q: How do I find unused Roles?:: Correlate audit logs (no verb hits over a period) or use RHACS/RBAC reporting to flag dormant bindings.

Q: Is a ClusterRole ever required for this pattern?:: Not for namespaced config objects. Prefer Role unless you truly need cluster‑scope resources.

Q: Does this slow developers down?:: Properly documented Roles speed them up—less fear of breaking unrelated resources.

== Closing Story
Losing a broad credential is like misplacing the building master key. Losing a precise RBAC key is like misplacing the supply closet key—annoying, not catastrophic. Precision today is cheaper than forensics tomorrow.

== Next Step Ideas
* Add an admission policy forbidding new Roles with `*` verbs.
* Generate a nightly report: subjects vs allowed sensitive verbs.
* Introduce GitOps for RBAC so diffs become auditable reviews.
* Layer RHACS policy to alert on sudden new write verbs for “config-only” identities.

